# Laboratory Work 1: Intro to Formal Languages. Regular Grammars. Finite Automata

**Author:** Cretu Dumitru  
**Course:** Formal Languages & Finite Automata  
**Variant:** 9  
**Date:** February 11, 2026
**Student:** Bulimar Rodion
**Group:** FAF-242

---

## 1. Introduction

A formal language is a set of strings formed from an alphabet, governed by specific rules. The main components include an alphabet of valid symbols, variables that can be replaced, symbols that appear in final strings, rules for replacing non-terminals, and an initial non-terminal. This laboratory work focuses on regular grammars, known as Type-3 grammars, and their corresponding finite automata.

---

## 2. Objectives

The primary objectives of this laboratory work include implementing a Grammar class for variant 9, generating five valid strings from the grammar, converting the grammar to an equivalent Finite Automaton, implementing a method to verify whether a string belongs to the language, and documenting the work in both README.md and REPORT.md files.

---

## 3. Implementation

### Grammar Definition for Variant 9

The grammar for variant 9 is defined with non-terminals VN = {S, B, D, Q} and terminals VT = {a, b, c, d}. The start symbol is S, and the production rules are as follows:

S → aB  
S → bB  
B → cD  
D → dQ  
Q → bB  
D → a  
Q → dQ

### String Generation Process

### 3.3 String Generation Method

The string generation method implements a leftmost derivation algorithm. The method begins by initializing a current string containing only the start symbol S. While the current string contains any non-terminal symbols, the method identifies the leftmost non-terminal and retrieves all possible productions for that non-terminal. A random production is selected from the available options, and the leftmost non-terminal is replaced with the chosen right-hand side. This process continues until the string contains only terminal symbols. The method includes safeguards against infinite recursion by implementing a maximum derivation step limit.

```python
def generate_string(self):
    current_string = "S"
    max_steps = 100
    steps = 0
    
    while any(symbol.isupper() for symbol in current_string) and steps < max_steps:
        for i, symbol in enumerate(current_string):
            if symbol.isupper():
                leftmost_nonterminal = symbol
                production_choices = self.productions[leftmost_nonterminal]
                chosen_production = random.choice(production_choices)
                current_string = current_string[:i] + chosen_production + current_string[i+1:]
                break
        steps += 1
    
    return current_string
```

### Grammar to Finite Automaton Conversion

Each production in the grammar is converted to a corresponding transition in the finite automaton. The production S → aB becomes δ(S, a) = B, S → bB becomes δ(S, b) = B, B → cD becomes δ(B, c) = D, D → dQ becomes δ(D, d) = Q, Q → bB becomes δ(Q, b) = B, D → a becomes δ(D, a) = F, and Q → dQ becomes δ(Q, d) = Q. The resulting automaton consists of states Q = {S, B, D, Q, F} with an alphabet Σ = {a, b, c, d}. The initial state is q0 = S, and the final states are F = {F}.

| Production | Transition |
|------------|------------|
| S → aB | δ(S, a) = B |
| S → bB | δ(S, b) = B |
| B → cD | δ(B, c) = D |
| D → dQ | δ(D, d) = Q |
| Q → bB | δ(Q, b) = B |
| D → a | δ(D, a) = F |
| Q → dQ | δ(Q, d) = Q |

### String Validation Method

The string belonging method determines whether a given string can be generated by the grammar. This method implements a recursive backtracking algorithm that attempts to derive the target string from the start symbol. The algorithm maintains the current derived string and the target string, applying productions to non-terminals and comparing the result with the target. When the derived string length exceeds the target length, the algorithm backtracks to explore alternative productions. The method returns true if a derivation path leading exactly to the target string is found.

``` python
def string_belongs_to_language(self, input_string: str) -> bool:
        current_states = {self.initial_state}
        for char in input_string:
            if char not in self.alphabet:
                return False
            
            next_states = set()
            for state in current_states:
                if state in self.transitions and char in self.transitions[state]:
                    next_states.update(self.transitions[state][char])
            
            if not next_states:
                return False
            
            current_states = next_states
        return bool(current_states & self.final_states)
```

---

## 4. Results

### Generated Strings

Running the program produced five valid strings: acd, bdQ, a, acdQ, and bcda. Additional strings generated for testing included bcdQ and acddQ.

### Validation Results

The validation results show that several strings are accepted by the automaton. The string acd was accepted, bdQ was accepted, a was accepted, acdQ was accepted, bcda was accepted, bcdQ was accepted, and acddQ was accepted.

Several strings were rejected for various reasons. The empty string was rejected because there is no transition from the initial state. The string abc was rejected because there is no transition from B with the symbol b. The string bac was rejected because there is no transition from B with the symbol a. The string ccc was rejected because valid strings must start with S. The string dddd was rejected for the same reason. The string acb was rejected because there is no transition from D with the symbol b. The string b was rejected because B is not a final state.

### Grammar Analysis

The grammar is classified as Type-3, or regular, with all productions following the right-linear form. There are seven total productions, and the language generated is infinite due to the production Q → dQ. The grammar contains no epsilon productions.

### Automaton Analysis

The automaton consists of five states and seven transitions. It is deterministic, meaning no state has multiple transitions on the same input symbol. The initial state is S, and the only final state is F.

---

## 5. Conclusions

### Summary of Achievements

All tasks for this laboratory work were completed successfully. The Grammar class was implemented, five valid strings were generated, the grammar was converted to a finite automaton, the string validation method was implemented, and the documentation was completed.

### Key Findings

The grammar is Type-3 and regular, as all productions follow the right-linear form A → aB or A → a. The automaton is deterministic with no conflicting transitions. The language generated is infinite because the production Q → dQ creates a cycle, allowing strings of arbitrary length. All valid strings must start with either a or b, have c as the second character, and then either end with a or continue with a sequence of d symbols.

### Lessons Learned

Regular grammars, despite their simplicity, can describe infinite languages. Leftmost derivation provides a systematic approach to string generation. Simulating an NFA using sets of states is straightforward to implement. Testing edge cases, including the empty string and invalid symbols, is essential for robust validation. The equivalence between grammars and finite automata demonstrates that these two representations capture the same class of languages.

### Future Improvements

Possible improvements for future work include adding DFA minimization, generating regular expressions from the automaton, visualizing the automaton as a graph, and extending support to context-free grammars.

---

## 6. References

Drumea, V. and Cojuhari, I. Formal Languages and Finite Automata. Technical University of Moldova, 2026.

Hopcroft, J. E., Motwani, R., and Ullman, J. D. Introduction to Automata Theory, Languages, and Computation. 3rd ed., Addison-Wesley, 2006.

Sipser, M. Introduction to the Theory of Computation. 3rd ed., Cengage Learning, 2012.

---

## 7. Declaration

I hereby declare that this laboratory work is my own original work and has been completed in accordance with the academic integrity policy of the Technical University of Moldova.

**Student:** Bulimar Rodion  
**Group:** FAF-242  
**Date:** February 11, 2026  

---

*End of Report*


